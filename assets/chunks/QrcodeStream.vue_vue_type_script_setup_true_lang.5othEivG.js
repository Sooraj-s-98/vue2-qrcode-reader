import{d as K,h as d,j as X,A as Y,g as k,y as R,a8 as Z,o as ee,c as te,k as m,O as oe,a4 as ae,a6 as ne,r as se}from"./framework.ESQuMJT-.js";import{s as H,b as a,c as re,d as ie,k as ce}from"./camera.tNqVZ9MC.js";const ue=K({__name:"QrcodeStream",props:{constraints:{type:Object,default(){return{facingMode:"environment"}}},formats:{type:Array,default:()=>["qr_code"]},paused:{type:Boolean,default:!1},torch:{type:Boolean,default:!1},track:{type:Function}},emits:["detect","camera-on","camera-off","error"],setup(F,{emit:L}){const n=F,u=L,h=d(),f=d(),c=d(),y=d(!1),v=d(!1);X(()=>{v.value=!0}),Y(()=>{H()});const _=k(()=>({torch:n.torch,constraints:n.constraints,shouldStream:v.value&&!n.paused}));R(_,async t=>{const e=c.value;a(e!==void 0,"cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined.");const o=h.value;a(o!==void 0,"cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined.");const l=o.getContext("2d");if(a(l!==null,"if cavnas is defined, canvas 2d context should also be non-null"),t.shouldStream)try{const r=await re(e,t);v.value?(y.value=!0,u("camera-on",r)):await H()}catch(r){u("error",r)}else o.width=e.videoWidth,o.height=e.videoHeight,l.drawImage(e,0,0,e.videoWidth,e.videoHeight),H(),y.value=!1,u("camera-off")},{deep:!0});const{formats:j}=Z(n);R(j,t=>{v.value&&ie(t)});const p=k(()=>_.value.shouldStream&&y.value);R(p,t=>{if(t){a(h.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined"),g(h.value),a(f.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined"),g(f.value);const e=()=>n.track===void 0?500:40;a(c.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus video element is defined"),ce(c.value,{detectHandler:o=>u("detect",o),formats:n.formats,locateHandler:C,minDelay:e()})}});const g=t=>{const e=t.getContext("2d");a(e!==null,"canvas 2d context should always be non-null"),e.clearRect(0,0,t.width,t.height)},C=t=>{const e=f.value;a(e!==void 0,"onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined.");const o=c.value;if(a(o!==void 0,"onLocate handler should only be called when component is mounted. Thus video element is always defined."),t.length===0||n.track===void 0)g(e);else{const l=o.offsetWidth,r=o.offsetHeight,x=o.videoWidth,S=o.videoHeight,W=Math.max(l/x,r/S),B=x*W,T=S*W,D=B/x,E=T/S,z=(l-B)/2,I=(r-T)/2,b=({x:i,y:s})=>({x:Math.floor(i*D),y:Math.floor(s*E)}),O=({x:i,y:s})=>({x:Math.floor(i+z),y:Math.floor(s+I)}),P=t.map(i=>{const{boundingBox:s,cornerPoints:Q}=i,{x:U,y:V}=O(b({x:s.x,y:s.y})),{x:$,y:G}=b({x:s.width,y:s.height});return{...i,cornerPoints:Q.map(J=>O(b(J))),boundingBox:DOMRectReadOnly.fromRect({x:U,y:V,width:$,height:G})}});e.width=o.offsetWidth,e.height=o.offsetHeight;const N=e.getContext("2d");n.track(P,N)}},q={width:"100%",height:"100%",position:"relative","z-index":"0"},M={width:"100%",height:"100%",position:"absolute",top:"0",left:"0"},w={width:"100%",height:"100%","object-fit":"cover"},A=k(()=>p.value?w:{...w,visibility:"hidden",position:"absolute"});return(t,e)=>(ee(),te("div",{style:q},[m("video",{ref_key:"videoRef",ref:c,style:oe(A.value),autoplay:"",muted:"",playsinline:""},null,4),ae(m("canvas",{id:"qrcode-stream-pause-frame",ref_key:"pauseFrameRef",ref:h,style:w},null,512),[[ne,!p.value]]),m("canvas",{id:"qrcode-stream-tracking-layer",ref_key:"trackingLayerRef",ref:f,style:M},null,512),m("div",{style:M},[se(t.$slots,"default")])]))}});export{ue as _};
